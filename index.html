<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Voxel Architect – Mobile Touch + Gyro</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body{
  margin:0;
  background:#000;
  overflow:hidden;
  font-family:monospace;
  touch-action:none;
}
#ui{
  position:absolute;
  top:10px;
  left:10px;
  z-index:10;
  background:rgba(0,0,0,0.6);
  color:#00f0ff;
  padding:12px;
  border-left:3px solid #00f0ff;
  font-size:12px;
}
.stat{color:#fff}
canvas{display:block}
</style>
</head>

<body>

<div id="ui">
  <div>ARCHITECT_OS – MOBILE MODE</div>
  <div>MODE: <span class="stat">TOUCH + GYRO</span></div>
  <div>VOXELS: <span id="count" class="stat">0</span></div>
  <div style="font-size:10px;color:#ffcc00">
    Tap: Build | Hold: Erase | Tilt: Rotate
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ========= BASIC SETUP ========= */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0,20);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const light = new THREE.DirectionalLight(0x00f0ff,1);
light.position.set(5,5,5);
scene.add(light);

const voxelGroup = new THREE.Group();
scene.add(voxelGroup);

/* ========= VOXELS ========= */
const grid = 1.2;
const placed = new Map();
const countEl = document.getElementById("count");

function makeCube(x,y,z){
  const g = new THREE.BoxGeometry(grid*0.95,grid*0.95,grid*0.95);
  const m = new THREE.MeshPhongMaterial({
    color:0x001122,
    emissive:0x00f0ff,
    emissiveIntensity:0.4
  });
  const cube = new THREE.Mesh(g,m);
  cube.position.set(x,y,z);
  return cube;
}

/* ========= RAYCAST ========= */
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function snap(v){
  return Math.round(v/grid)*grid;
}

function placeOrErase(x,y,erase=false){
  pointer.x = (x/innerWidth)*2-1;
  pointer.y = -(y/innerHeight)*2+1;
  raycaster.setFromCamera(pointer,camera);

  const pos = raycaster.ray.origin.clone()
    .add(raycaster.ray.direction.clone().multiplyScalar(20));

  const gx = snap(pos.x);
  const gy = snap(pos.y);
  const gz = snap(pos.z);
  const key = `${gx},${gy},${gz}`;

  if(erase){
    if(placed.has(key)){
      voxelGroup.remove(placed.get(key));
      placed.delete(key);
    }
  }else{
    if(!placed.has(key)){
      const c = makeCube(gx,gy,gz);
      voxelGroup.add(c);
      placed.set(key,c);
    }
  }
  countEl.innerText = placed.size;
}

/* ========= TOUCH ========= */
let holdTimer = null;

canvas.addEventListener("touchstart", e=>{
  const t = e.touches[0];
  holdTimer = setTimeout(()=>{
    placeOrErase(t.clientX,t.clientY,true);
  },450);
});

canvas.addEventListener("touchend", e=>{
  if(holdTimer){
    clearTimeout(holdTimer);
    const t = e.changedTouches[0];
    placeOrErase(t.clientX,t.clientY,false);
  }
  holdTimer = null;
});

/* ========= GYRO ========= */
if(window.DeviceOrientationEvent){
  window.addEventListener("deviceorientation", e=>{
    voxelGroup.rotation.x = e.beta * 0.01;
    voxelGroup.rotation.y = e.gamma * 0.01;
  });
}

/* ========= DESKTOP MOUSE ========= */
let dragging=false,lastX=0,lastY=0;

canvas.addEventListener("mousedown",e=>{
  dragging=true;lastX=e.clientX;lastY=e.clientY;
});
canvas.addEventListener("mousemove",e=>{
  if(dragging){
    voxelGroup.rotation.y += (e.clientX-lastX)*0.005;
    voxelGroup.rotation.x += (e.clientY-lastY)*0.005;
    lastX=e.clientX;lastY=e.clientY;
  }
});
canvas.addEventListener("mouseup",()=>dragging=false);
canvas.addEventListener("contextmenu",e=>{
  e.preventDefault();
  placeOrErase(e.clientX,e.clientY,true);
});
canvas.addEventListener("click",e=>{
  placeOrErase(e.clientX,e.clientY,false);
});

/* ========= LOOP ========= */
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
